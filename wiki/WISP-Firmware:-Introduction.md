# WISP Firmware: Introduction
This article introduces part of the WISP firmware that relates to the WISP Extended Runtime.

## Run Once Project
The WISP Extended Runtime contains a [Run Once](https://github.com/lqf96/wisp-ert/tree/master/client/run-once) project, which is originally from the WISP5 firmware repository. The program in this project generates and stores random numbers for further WISP RFID communications. You should run this project once before moving on to the WISP ERT demo. When you see the LED light shining it means the initialization work is done.

## MSP430 Interrupts
Like most of the other architectures, MSP430 supports hardware interrupts. An interrupt routine is defined with `#pragma vector=[Interrupt Vector]` and keyword `__interrupt`. Since the CPU will reset if an interrupt is unhandled, every WISP5 project should include a [fallback interrupt handler](https://github.com/wisp/wisp5/blob/640kHz/CCS/simpleAckDemo/catchall.c) to catch all unhandled interrupts. If you want to handle an interrupt in this case, don't forget to comment out corresponding `#pragma` directive or you will get redefinition errors.

## RFID Features
The WISP5 firmware provides a group of functions to do RFID communication. The [simple acknowledgement demo](https://github.com/wisp/wisp5/blob/640kHz/CCS/simpleAckDemo/main.c) from the offical repository serves as a good example of the functions.

First of all, you should call [`WISP_init()`](https://lqf96.github.io/wisp-ert/client/html/wisp-base_8h.html#a0b8edee3467ada8a0ab500ec2e261558) to initialize the functionality of WISP firmware.

The `WISP_registerCallback_*()` group of functions can be used to set the hooks for RFID Read, Write, BlockWrite and Acknowledgement operations. These hook functions will be called after the RFID operation completes. Function [`WISP_setMode()`](https://lqf96.github.io/wisp-ert/client/html/rfid_8h.html#a6efafd164806e7c662eccedc6fe1f2b2) and [`WISP_setAbortConditions()`](https://lqf96.github.io/wisp-ert/client/html/rfid_8h.html#a270dad336bfcea3625f8b0cf08355ce4) can be used to set up operating parameters for WISP RFID communication routines.

To get access to the WISP RFID data buffers, first prepare a piece of buffer for BlockWrite, sets the value of [`RWData.bwrBufPtr`](https://lqf96.github.io/wisp-ert/client/html/struct_r_wstruct.html#a4e8dad7aa9836e390d43a5fcc56b2b25) to the buffer you just created. Then, create an instance of [`WISP_dataStructInterface_t`](https://lqf96.github.io/wisp-ert/client/html/struct_w_i_s_p__data_struct_interface__t.html) and pass the pointer of the instance to [`WISP_getDataBuffers()`](https://lqf96.github.io/wisp-ert/client/html/wisp-base_8h.html#ac0e0e49d378e252126e4d30d3a06b4fd), and now you can get access to the [Read](https://lqf96.github.io/wisp-ert/client/html/struct_w_i_s_p__data_struct_interface__t.html#a72f940d96b1f6eb611bd1597175d279f), [Write](https://lqf96.github.io/wisp-ert/client/html/struct_w_i_s_p__data_struct_interface__t.html#ab3e060170e3d3bbaf7365505444e0b26), [BlockWrite](https://lqf96.github.io/wisp-ert/client/html/struct_w_i_s_p__data_struct_interface__t.html#ab586eee1b2f3694591d1bde7520889cb) and [EPC](https://lqf96.github.io/wisp-ert/client/html/struct_w_i_s_p__data_struct_interface__t.html#a7d51b93bf2c07724afffdc99a5cbd237) buffer. Note that because of the way Impinj reader does BlockWrite, it isn't possible to get the size of the BlockWrite through [`blockWriteSizePtr`](https://lqf96.github.io/wisp-ert/client/html/struct_w_i_s_p__data_struct_interface__t.html#aa87151e1e834db182f5ab72d4f55e4d2). You have to prepend the length of the data to work around this problem.

Before we go into the RFID loop, we need to set up the EPC-96 field. In the original WISP5 demo, the last three bytes contain the WISP RFID class and the WISP ID. In the WISP Extended Runtime, the WISP RFID class and the WISP ID is instead placed in the first two bytes. All other ten bytes are used by WTP to send data to the server.
